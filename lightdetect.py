# -*- coding: utf-8 -*-
"""lightdetect.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RFnLo9e-8xHwCAQCzupMdPTIxavoQ-5H

# LIGHT **DETECTION**
"""

from google.colab import drive
drive.mount('/content/drive')

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# === Blob Detection Helper ===
def detect_blobs(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    params = cv2.SimpleBlobDetector_Params()
    params.filterByColor = True
    params.blobColor = 255

    params.filterByArea = False
    params.minArea = 300
    params.maxArea = 700

    params.filterByCircularity = True
    params.minCircularity = 0.55
    params.filterByConvexity = False
    params.minConvexity = 0.7

    detector = cv2.SimpleBlobDetector_create(params)
    return detector.detect(gray)

def get_intensity(hsv_image, x, y, size):
    radius = int(size / 2)
    x1, y1 = max(0, x - radius), max(0, y - radius)
    x2, y2 = min(hsv_image.shape[1], x + radius), min(hsv_image.shape[0], y + radius)
    roi = hsv_image[y1:y2, x1:x2]
    if roi.size == 0:
        return 0
    # Average intensity from V channel
    return np.mean(roi[:, :, 2]) / 255.0

def point_inside_contours(point, contours):
    for contour in contours:
        if cv2.pointPolygonTest(contour, point, False) >= 0:
            return True
    return False

# fourcc = cv2.VideoWriter_fourcc(*'MJPG')
# out = cv2.VideoWriter('/content/drive/MyDrive/lightDetection/res.avi', fourcc, 20.0, (500, 300))

# === Load Image ===

video_path = '/content/drive/MyDrive/lightDetection/vidt5.mp4'
cap = cv2.VideoCapture(video_path)

while cap.isOpened():
    ret, image = cap.read()
    if not ret:
        break

    image = cv2.resize(image, (500, 300))

# === Process Image ===
    denoised = cv2.fastNlMeansDenoisingColored(image, None, 20, 20, 7, 21)
    img_float = denoised.astype(np.float32) / 255.0

    luminance = 0.2126 * img_float[:, :, 0] + 0.7152 * img_float[:, :, 1] + 0.0722 * img_float[:, :, 2]
    bright_mask = luminance > 0.83
    bright_pass = np.zeros_like(img_float)
    bright_pass[bright_mask] = img_float[bright_mask]

    blurred = cv2.GaussianBlur(bright_pass, (0, 0), sigmaX=20, sigmaY=20)
    bloomed = np.clip(img_float + blurred * 5, 0, 1)
    bloomed_uint8 = (bloomed * 255).astype(np.uint8)

    darker = cv2.subtract(bloomed_uint8, np.full(bloomed_uint8.shape, 75, dtype=np.uint8))
    blurred_final = cv2.GaussianBlur(darker, (15, 15), 0)

    hsv = cv2.cvtColor(blurred_final, cv2.COLOR_BGR2HSV)
    kernel = np.ones((5, 5), "uint8")

    # === Define Color Masks ===
    color_ranges = {
        "Red": [
            (np.array([3, 100, 100]), np.array([10, 255, 255])),
            (np.array([160, 100, 100]), np.array([175, 255, 255]))
        ],
        "Green": [(np.array([40, 52, 72]), np.array([85, 255, 255]))],
        "Blue": [(np.array([100, 120, 40]), np.array([140, 255, 255]))],
        "Yellow": [(np.array([19, 93, 0]), np.array([41, 255, 255]))]
    }

    color_contours = {}
    for color, ranges in color_ranges.items():
        combined_mask = None
        for lower, upper in ranges:
            mask = cv2.inRange(hsv, lower, upper)
            if combined_mask is None:
                combined_mask = mask
            else:
                combined_mask = cv2.bitwise_or(combined_mask, mask)

        # Apply morphological operations
        morph_kernel = np.ones((3, 3), np.uint8)

        # Opening removes small noise (erosion followed by dilation)
        cleaned_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_OPEN, morph_kernel, iterations=2)

        # Slight dilation to ensure contours are well-formed but don't merge too much
        dilated_mask = cv2.dilate(cleaned_mask, morph_kernel, iterations=1)

        contours, _ = cv2.findContours(dilated_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        color_contours[color] = contours

        # cv2.drawContours(image, contours, -1, {
        #     "Red": (0, 0, 255),
        #     "Green": (0, 255, 0),
        #     "Blue": (255, 0, 0),
        #     "Yellow": (0, 255, 255)
        # }[color], 2)

    # === Blob Detection ===
    keypoints = detect_blobs(blurred_final)

    for kp in keypoints:
      x, y = int(kp.pt[0]), int(kp.pt[1])
      intensity = get_intensity(hsv, x, y, kp.size)

      if intensity < 0.55:  # ðŸ”´ Skip dim blobs
       continue
      found = False
      for color_name, contours in color_contours.items():
          if point_inside_contours((x, y), contours):
              cv2.circle(image, (x, y), int(kp.size / 2), (255, 255, 255), 2)
              cv2.putText(image, f"{color_name} Light", (x + 5, y - 5),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
              found = True
              break
     # if not found:
          # Mark as white light if not found in any known color
        #  cv2.circle(image, (x, y), int(kp.size / 2), (255, 255, 255), 2)
        #  cv2.putText(image, "White ", (x + 5, y - 5),
        #              cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)


      #Save or display the result
      # out.write(image)

      cv2_imshow(image)




cap.release()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# === Blob Detection Helper ===
def detect_blobs(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    params = cv2.SimpleBlobDetector_Params()
    params.filterByColor = True
    params.blobColor = 255

    params.filterByArea = True
    params.minArea = 500


    params.filterByCircularity = True
    params.minCircularity = 0.5
    params.filterByConvexity = False
    params.minConvexity = 0.7

    detector = cv2.SimpleBlobDetector_create(params)
    return detector.detect(gray)

def point_inside_contours(point, contours):
    for contour in contours:
        if cv2.pointPolygonTest(contour, point, False) >= 0:
            return True
    return False

# fourcc = cv2.VideoWriter_fourcc(*'MJPG')
# out = cv2.VideoWriter('/content/drive/MyDrive/lightDetection/off1.avi', fourcc, 20.0, (500, 300))

# === Load Image ===

video_path = '/content/drive/MyDrive/lightDetection/vidt3.mp4'
cap = cv2.VideoCapture(video_path)

while cap.isOpened():
    ret, image = cap.read()
    if not ret:
        break

    image = cv2.resize(image, (500, 300))

# === Process Image ===
    denoised = cv2.fastNlMeansDenoisingColored(image, None, 20, 20, 7, 21)
    img_float = denoised.astype(np.float32) / 255.0

    luminance = 0.2126 * img_float[:, :, 0] + 0.7152 * img_float[:, :, 1] + 0.0722 * img_float[:, :, 2]
    bright_mask = luminance > 0.7
    bright_pass = np.zeros_like(img_float)
    bright_pass[bright_mask] = img_float[bright_mask]

    blurred = cv2.GaussianBlur(bright_pass, (0, 0), sigmaX=20, sigmaY=20)
    bloomed = np.clip(img_float + blurred * 5, 0, 1)
    bloomed_uint8 = (bloomed * 255).astype(np.uint8)

    darker = cv2.subtract(bloomed_uint8, np.full(bloomed_uint8.shape, 75, dtype=np.uint8))
    blurred_final = cv2.GaussianBlur(darker, (15, 15), 0)

    hsv = cv2.cvtColor(blurred_final, cv2.COLOR_BGR2HSV)
    kernel = np.ones((5, 5), "uint8")

    # === Define Color Masks ===
    color_ranges = {
        "Red": [
            (np.array([0, 100, 100]), np.array([10, 255, 255])),
            (np.array([160, 100, 100]), np.array([180, 255, 255]))
        ],
        "Green": [(np.array([40, 52, 72]), np.array([85, 255, 255]))],
        "Blue": [(np.array([100, 120, 40]), np.array([140, 255, 255]))],
        "Yellow": [(np.array([20, 93, 0]), np.array([40, 255, 255]))]
    }

    color_contours = {}
    for color, ranges in color_ranges.items():
        combined_mask = None
        for lower, upper in ranges:
            mask = cv2.inRange(hsv, lower, upper)
            if combined_mask is None:
                combined_mask = mask
            else:
                combined_mask = cv2.bitwise_or(combined_mask, mask)
        combined_mask = cv2.dilate(combined_mask, kernel)
        contours, _ = cv2.findContours(combined_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        color_contours[color] = contours
        # cv2.drawContours(image, contours, -1, {
        #    "Red": (0, 0, 255),
        #    "Green": (0, 255, 0),
        #    "Blue": (255, 0, 0),
        #    "Yellow": (0, 255, 255)
        # }[color], 2)

    # === Blob Detection ===
    keypoints = detect_blobs(blurred_final)

    for kp in keypoints:
      x, y = int(kp.pt[0]), int(kp.pt[1])
      found = False
      for color_name, contours in color_contours.items():
          if point_inside_contours((x, y), contours):
              print()
              cv2.circle(image, (x, y), int(kp.size / 2), (255, 255, 255), 2)
              cv2.putText(image, f"{color_name} Light", (x + 5, y - 5),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
              found = True
              break
      # if not found:
      #     # Mark as white light if not found in any known color
      #     cv2.circle(image, (x, y), int(kp.size / 2), (255, 255, 255), 2)
      #     cv2.putText(image, "White ", (x + 5, y - 5),
      #                 cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)


    # Save or display the result
     # out.write(image)

    cv2_imshow(image)



cap.release()